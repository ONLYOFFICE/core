#include "CFont.h"

namespace SVG 
{
	CGlyph::CGlyph(CSvgReader& oReader)
		: CPath(oReader)
	{
		START_READ_ATTRIBUTES(oReader)
		{
			if ("unicode" == sAttributeName)
			{
				const std::wstring wsUnicode{oReader.GetText()};

				if (!wsUnicode.empty())
					m_wchUnicode = wsUnicode[0];
			}
			else if ("horiz-adv-x" == sAttributeName)
				m_oHorizAdvX.SetValue(oReader.GetText());
		}
		END_READ_ATTRIBUTES(oReader)
	}

	wchar_t CGlyph::GetUnicode() const
	{
		return m_wchUnicode;
	}

	CFontFace::CFontFace(CSvgReader& oReader)
	{}

	CFont::CFont(CSvgReader& oReader)
		: CAppliedObject(oReader), m_pMissingGlyph(NULL)
	{
		START_READ_ATTRIBUTES(oReader)
		{
			if ("font-variant" == sAttributeName)
				m_oArguments.m_wsFontVariant = oReader.GetText();
			else if ("font-style" == sAttributeName)
				m_oArguments.m_wsFontStyle = oReader.GetText();
			else if ("font-weight" == sAttributeName)
				m_oArguments.m_wsFontWidght = oReader.GetText();
			else if ("horiz-adv-x" == sAttributeName)
				m_oHorizAdvX.SetValue(oReader.GetText());
		}
		END_READ_ATTRIBUTES(oReader)

		ParseGlyphs(oReader);
	}

	CFont::~CFont()
	{
		for (std::pair<wchar_t, CGlyph*> oElement : m_mGlyphs)
			RELEASEOBJECT(oElement.second);

		RELEASEOBJECT(m_pMissingGlyph);
	}

	void CFont::SetData(const std::map<std::wstring, std::wstring> &mAttributes, unsigned short ushLevel, bool bHardMode)
	{
	}

	bool CFont::Apply(IRenderer *pRenderer, const CSvgFile *pFile, const TBounds &oObjectBounds)
	{
		return false;
	}

	bool CFont::Draw(const std::wstring &wsText, const double& dX, const double& dY, const double& dFontHeight, IRenderer *pRenderer, const CSvgFile *pFile, CommandeMode oMode, const TSvgStyles *pStyles, const CRenderedObject* pContexObject) const
	{
		if (NULL == pRenderer || wsText.empty())
			return false;
		
		double dM11, dM12, dM21, dM22, dRx, dRy;

		pRenderer->GetTransform(&dM11, &dM12, &dM21, &dM22, &dRx, &dRy);

		Aggplus::CMatrix oMatrix(dM11, dM12, dM21, dM22, dRx, dRy);
		oMatrix.Translate(dX, dY);

		MGlyphsMap::const_iterator itFound;
		double dGlyphScale = 1.;

		#define DrawGlyph(glyphPtr, function) \
		const TBounds oGlyphBound{glyphPtr->GetBounds()};\
		if (Equals(0., dFontHeight) || Equals(oGlyphBound.m_dBottom, oGlyphBound.m_dTop) || Equals(oGlyphBound.m_dRight, oGlyphBound.m_dLeft)) \
			continue; \
		dGlyphScale = dFontHeight / 1000.; \
		if (!Equals(1., dGlyphScale)) \
		{ \
			oMatrix.Scale(dGlyphScale, -dGlyphScale); \
			pRenderer->SetTransform(oMatrix.sx(), oMatrix.shy(), oMatrix.shx(), oMatrix.sy(), oMatrix.tx(), oMatrix.ty()); \
		} \
		function; \
		if (!Equals(1., dGlyphScale)) \
		{ \
			oMatrix.Scale(1. / dGlyphScale, -1. / dGlyphScale); \
			pRenderer->SetTransform(oMatrix.sx(), oMatrix.shy(), oMatrix.shx(), oMatrix.sy(), oMatrix.tx(), oMatrix.ty()); \
		} \

		for (wchar_t wchGlyph : wsText)
		{
			itFound = m_mGlyphs.find(wchGlyph);

			if (m_mGlyphs.cend() == itFound)
			{
				if (NULL == m_pMissingGlyph)
					continue;

				DrawGlyph(m_pMissingGlyph, m_pMissingGlyph->Draw(pRenderer, pFile, oMode, pStyles, pContexObject))

				oMatrix.Translate(m_oHorizAdvX.ToDouble(NSCSS::Pixel), 0);
			}
			else
			{
				DrawGlyph(itFound->second, itFound->second->Draw(pRenderer, pFile, oMode, pStyles, pContexObject))

				if (!itFound->second->m_oHorizAdvX.Empty())
					oMatrix.Translate(itFound->second->m_oHorizAdvX.ToDouble(NSCSS::Pixel), 0);
				else
					oMatrix.Translate(m_oHorizAdvX.ToDouble(NSCSS::Pixel), 0);
			}

			pRenderer->SetTransform(oMatrix.sx(), oMatrix.shy(), oMatrix.shx(), -oMatrix.sy(), oMatrix.tx(), oMatrix.ty());
		}

		pRenderer->SetTransform(dM11, dM12, dM21, dM22, dRx, dRy);

		return true;
	}

	void CFont::ParseGlyphs(CSvgReader& oReader)
	{
		WHILE_READ_NEXT_NODE_WITH_NAME(oReader)
		{
			if ("glyph" == sNodeName)
			{
				CGlyph *pGlyph = new CGlyph(oReader);

				if (NULL == pGlyph)
					continue;

				if (m_mGlyphs.end() == m_mGlyphs.find(pGlyph->GetUnicode()))
					m_mGlyphs.insert(std::make_pair(pGlyph->GetUnicode(), pGlyph));
				else
					delete pGlyph;
			}
			else if ("missing-glyph" == sNodeName)
			{
				WHILE_READ_NEXT_NODE_WITH_DEPTH_ONE_NAME(oReader, Child, "path")
				{
					m_pMissingGlyph = new CPath(oReader);
					if (NULL != m_pMissingGlyph)
						break;
				}
				END_WHILE
			}
		}
		END_WHILE
	}
}
