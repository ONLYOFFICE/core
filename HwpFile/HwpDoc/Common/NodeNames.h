#ifndef NODENAMES_H
#define NODENAMES_H

#include "../HanType.h"

namespace HWP
{
enum class ENode
{
	//HEAD
	BeginNum,
	FaceNameList,
		FontFace,
			Font,
				SubFont,
				TypeInfo,
	BorderFillList,
		BorderFill,
			LeftBorder,
			RightBorder,     //10
			TopBorder,
			BottomBorder,
			Diagonal,
			FillBrush,
				WindowBrush,
				Gradation,
					Color,
				ImageBrush,
					Image,
	CharShapeList,           //20
		CharShape,
			FontId,
			Ratio,
			CharSpacing,
			RelSize,
			CharOffset,
			Italic,
			Bold,
			Underline,
			Outline,         //30
			Shadow,
			Emboss,
			Engrave,
			SuperScript,
			SubScript,
	TabDefList,
		TabDef,
			TabItem,
	NumberingList,
		Numbering,           //40
			ParaHead,
	BulletList,
		Bullet,
			//ParaHead
	ParaShapeList,
		ParaShape,
			ParaMargin,
			ParaBorder,
	StyleList,
		Style,

	//BODY
	Body,                    //50
	Section,
	Paragraph,
	Text,
	Char,
	SectionDef,
	Table,
	Picture,
	Container,
	Ole,
	Equation,                //60
	TextArt,
	Line,
	Rectangle,
	Ellipse,
	Arc,
	Polygon,
	Curve,
	ConnectLine,
	Tab,
	LineBreak,               //70
	Hyphen,
	NbSpace,
	FwSpace,
	Size,
	Posistion,
	OutSideMargin,
	InSideMargin,
	Caption,
	TransformMatrix,
	ScaleMatrix,             //80
	RotationMatrix,
	LineShape,
	ShadowEffect,
	GlowEffect,
	SoftEdgeEffect,
	ReflectionEffect,
	EffectsColor,
	DrawText,
	TextMargin,
	Header,                  //90
	Footer,
	CellZoneList,
		CellZone,
	Row,
		Cell,
	AutoNum,
		AutoNumFormat,
	NewNum,
	FieldBegin,
	FieldEnd,                //100
	PageNum,
	FootNote,
	EndNote,
	ParaList,
	ColumnDef,
		ColumnLine,
	Script,
	Point,
	Segment,

	//Only hwpx
	Lineseg,
	LinesegArray,
	Video,
	Switch,
	Case,
	Default,
	Slash,
	BackSlash
};

#define MAX_TYPES 2
#define MAX_NODES 117

static constexpr const char* NODE_NAMES[MAX_TYPES][MAX_NODES] = 
{
// HWPX
	{
		//HEAD
		"hh:beginNum",
		"hh:fontfaces",
			"hh:fontface",
				"hh:font",
					"hh:substFont",
					"hh:typeInfo",
		"hh:borderFills",
			"hh:borderFill",
				"hh:leftBorder",
				"hh:rightBorder",     //10
				"hh:topBorder",
				"hh:bottomBorder",
				"hh:diagonal",
				"hc:fillBrush",
					"hc:winBrush",
					"hc:gradation",
						"hc:color",
					"hc:imgBrush",
						"hc:img",
		"h:charProperties",           //20
			"hh:charPr",
				"hh:fontRef",
				"hh:ratio",
				"hh:spacing",
				"hh:relSz",
				"hh:offset",
				"hh:italic",
				"hh:bold",
				"hh:underline",
				"hh:outline",         //30
				"hh:shadow",
				"hh:emboss",
				"hh:engrave",
				"hh:supscript",
				"hh:subscript",
		"hh:tabProperties",
			"hh:tabPr",
				"hh:tabPr",
		"hh:numberings",
			"hh:numbering",           //40
				"hh:paraHead",
		"hh:bullets",
			"hh:bullet",
				//"PARAHEAD",
		"hh:paraProperties",
			"hh:paraPr",
				"hh:margin",
				"hh:border",
		"hh:styles",
			"hh:style",

		//BODY
		"",                           //50
		"hs:sec",
		"hp:p",
		"hp:run",
		"hp:t",
		"hp:secPr",
		"hp:tbl",
		"hp:pic",
		"hp:container",
		"hp:ole",
		"hp:equation",                //60
		"hp:textart",
		"hp:line",
		"hp:rect",
		"hp:ellipse",
		"hp:arc",
		"hp:polygon",
		"hp:curve",
		"hp:connectLine",
		"hp:tab",
		"hp:lineBreak",               //70
		"hp:hyphen",
		"hp:nbSpace",
		"hp:fwSpace",
		"hp:sz",
		"hp:pos",
		"hp:outMargin",
		"hp:inMargin",
		"hp:caption",
		"hc:transMatrix",
		"hc:scaMatrix",
		"hc:rotMatrix",
		"hp:lineShape",
		"hp:shadow",
		"hp:glow",
		"hp:softEdge",
		"hp:reflection",
		"hp:effectsColor",
		"hp:drawText",
		"hp:textMargin",
		"hp:header",
		"hp:footer",
		"hp:cellzoneList",
			"hp:cellzone",
		"hp:tr",
			"hp:tc",
		"hp:autoNum",
			"hp:autoNumFormat",
		"hp:newNum",
		"hp:fieldBegin",
		"hp:fieldEnd",
		"hp:pageNum",
		"hp:footNote",
		"hp:endNote",
		"hp:subList",
		"hp:colPr",
			"hp:colLine",
		"hp:script",
		"hc:pt",
		"hp:seg",

		"hp:lineseg",
		"hp:linesegarray",
		"hp:video",
		"hp:switch",
		"hp:case",
		"hp:default",
		"hh:slash",
		"hh:backSlash"
	},
// HWPML
	{
		//HEAD
		"BEGINNUMBER",
		"FACENAMELIST",
			"FONTFACE",
				"FONT",
					"SUBSTFONT",
					"TYPEINFO",
		"BORDERFILLLIST",
			"BORDERFILL",
				"LEFTBORDER",
				"RIGHTBORDER",     //10
				"TOPBORDER",
				"BOTTOMBORDER",
				"DIAGONAL",
				"FILLBRUSH",
					"WINDOWBRUSH",
					"GRADATION",
						"COLOR",
					"IMAGEBRUSH",
						"IMAGE",
		"CHARSHAPELIST",           //20
			"CHARSHAPE",
				"FONTID",
				"RATIO",
				"CHARSPACING",
				"RELSIZE",
				"CHAROFFSET",
				"ITALIC",
				"BOLD",
				"UNDERLINE",
				"OUTLINE",         //30
				"SHADOW",
				"EMBOSS",
				"ENGRAVE",
				"SUPERSCRIPT",
				"SUBSCRIPT",
		"TABDEFLIST",
			"TABDEF",
				"TABITEM",
		"NUMBERINGLIST",
			"NUMBERING",           //40
				"PARAHEAD",
		"BULLETLIST",
			"BULLET",
				//"PARAHEAD",
		"PARASHAPELIST",
			"PARASHAPE",
				"PARAMARGIN",
				"PARABORDER",
		"STYLELIST",
			"STYLE",
		//BODY
		"BODY",                    //50
		"SECTION",
		"P",
		"TEXT",
		"CHAR",
		"SECDEF",
		"TABLE",
		"PICTURE",
		"CONTAINER",
		"OLE",
		"EQUATION",                //60
		"TEXTART",
		"LINE",
		"RECTANGLE",
		"ELLIPSE",
		"ARC",
		"POLYGON",
		"CURVE",
		"CONNECTLINE",
		"TAB",
		"LINEBREAK",               //70
		"HYPHEN",
		"NBSPACE",
		"FWSPACE",
		"SIZE",
		"POSITION",
		"OUTSIDEMARGIN",
		"INSIDEMARGIN",
		"CAPTION",
		"TRANSMATRIX",
		"SCAMATRIX",
		"ROTMATRIX",
		"LINESHAPE",
		"SHADOWEFFECT",
		"GLOW",
		"SOFTEDGE",
		"REFLECTION",
		"EFFECTSCOLOR",
		"DRAWTEXT",
		"TEXTMARGIN",
		"HEADER",
		"FOOTER",
		"CELLZONELIST",
			"CELLZONE",
		"ROW",
			"CELL",
		"AUTONUM",
			"AUTONUMFORMAT",
		"NEWNUM",
		"FIELDBEGIN",
		"FIELDEND",
		"PAGENUM",
		"FOOTNOTE",
		"ENDNOTE",
		"PARALIST",
		"COLDEF",
			"COLUMNLINE",
		"SCRIPT",
		"POINT",
		"SEGMENT",

		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	}
};

inline const char* GetNodeName(ENode eNode, EHanType eType)
{
	switch (eType)
	{
		case EHanType::HWPX:  return NODE_NAMES[0][static_cast<int>(eNode)];
		case EHanType::HWPML: return NODE_NAMES[1][static_cast<int>(eNode)];
		default: return "";
	}
}

inline bool Equals(ENode eNode, EHanType eType, std::string sNodeName)
{
	switch (eType)
	{
		case EHanType::HWPX:  return NODE_NAMES[0][static_cast<int>(eNode)] == sNodeName;
		case EHanType::HWPML: return NODE_NAMES[1][static_cast<int>(eNode)] == sNodeName;
		default: return false;
	}
}

enum class EAttribute
{
	ParaShape,
	Style,
	CharShape,
	Href,
	SubPath,
	MediaType,
	Type,
	FaceName,
	FamilyType,
	SerifStyle,     //10
	Weight,
	Proportion,
	Contrast,
	StrokeVariation,
	ArmStyle,
	Letterform,
	Midline,
	XHeight,
	ThreeD,
	Shadow,         //20
	Slash,
	BackSlash,
	CrookedSlash,
	CounterSlash,
	CounterBackSlash,
	BreakCellSeparateLine,
	Width,
	Color,
	FaceColor,
	HatchColor,     //30
	HatchStyle,
	Alpha,
	Angle,
	CenterX,
	CenterY,
	Step,
	ColorNum,
	StepCenter,
	Value,
	Mode,           //40
	Bright,
	Effect,
	BinItem,
	Height,
	TextColor,
	ShadeColor,
	UseFontSpace,
	UseKerning,
	SymMask,
	BorderFillId,   //50
	Shape,
	OffsetX,
	OffsetY,
	AutoTabLeft,
	AutoTabRight,
	Leader,
	Start,
	Level,
	Aligment,
	UseInstWidth,   //60
	AutoIndent,
	WidthAdjust,
	TextOffsetType,
	TextOffset,
	NumFormat,
	Char,
	Image,
	Align,
	VerAlign,
	HeadingType,    //70
	TabDef,
	BreakLatinWord,
	BreakNonLatinWord,
	Condense,
	WidowOrphan,
	KeepWithNext,
	KeepLines,
	PageBreakBefore,
	FontLineHeight,
	SnapToGrid,    //80
	LineWrap,
	AutoSpaceEAsianEng,
	AutoSpaceEAsianNum,
	Indent,
	Left,
	Right,
	Prev,
	Next,
	LineSpacingType,
	LineSpacing,   //90
	BorderFill,
	OffsetLeft,
	OffsetRight,
	OffsetTop,
	OffsetBottom,
	Connect,
	IgnoreMargin,
	EngName,
	NextStyle,
	LangId,        //100
	InstId,
	LockForm,
	Name,
	TextFlow,
	TextWrap,
	ZOrder,
	NumberingType,
	WidthRelTo,
	HeightRelTo,
	TreatAsChar,   //110
	AffectLSpacing,
	VertRelTo,
	VertAlign,
	HorzRelTo,
	HorzAlign,
	VertOffset,
	HorzOffset,
	FlowWithText,
	AllowOverlap,
	Top,           //120
	Bottom,
	Side,
	FullSize,
	Gap,
	LastWidth,
	MatrixElement1_1,
	MatrixElement1_2,
	MatrixElement2_1,
	MatrixElement2_2,
	MatrixElementOffsetX, // 130
	MatrixElementOffsetY,
	HeadStyle,
	HeadSize,
	TailStyle,
	TailSize,
	Radius,
	Direction,
	Distance,
	RotationStyle,
	FadeDirection,        //140
	BinData,
	RepeatHeader,
	RowCount,
	ColCount,
	CellSpacing,
	StartRowAddr,
	StartColAddr,
	EndRowAddr,
	EndColAddr,
	NumberType,           //150
	SuperScript,
	SubScript,
	FieldId,
	Pos,
	FormatType,
	SideChar,
	ColumnCount,
	SameSize,
	SameGap,
	Version,              //160
	BaseLine,
	BaseUnit,
	LineMode,
	X,
	Y,
	X1,
	Y1,
	X2,
	Y2,
	FontName,             //170
	FontStyle,
	FontType,
	TextShape,
	Spacing,

	PageBreak,
	ColumnBreak,
};

#define MAX_ATTRIBUTES 176

//TODO:: добавить все аргументы
static constexpr const char* ATTRUBUTE_NAMES[MAX_TYPES][MAX_ATTRIBUTES] = 
{
// HWPX
	{
		"paraPrIDRef",
		"styleIDRef",
		"charPrIDRef",
		"href",
		"sub-path",
		"media-type",
		"type",
		"face",
		"familyType",
		"serifStyle",     //10
		"weight",
		"proportion",
		"contrast",
		"strokeVariation",
		"armStyle",
		"letterform",
		"midline",
		"xHeight",
		"threeD",
		"shadow",         //20
		"",
		"",
		"",
		"",
		"",
		"breakCellSeparateLine",
		"width",
		"color",
		"faceColor",
		"hatchColor",     //30
		"hatchStyle",
		"alpha",
		"angle",
		"centerX",
		"centerY",
		"step",
		"colorNum",
		"stepCenter",
		"value",
		"mode",           //40
		"bright",
		"effect",
		"binaryItemIDRef",
		"height",
		"textColor",
		"shadeColor",
		"useFontSpace",
		"useKerning",
		"symMark",
		"borderFillIDRef",//50
		"shape",
		"offsetX",
		"offsetY",
		"autoTabLeft",
		"autoTabRight",
		"leader",
		"start",
		"level",
		"align",
		"useInstWidth",   //60
		"autoIndent",
		"widthAdjust",
		"textOffsetType",
		"textOffset",
		"numFormat",
		"charPrIDRef",
		"",
		"align",
		"verAlign",
		"",               //70
		"tabPrIDRef",
		"breakLatinWord",
		"breakNonLatinWord",
		"",
		"widowOrphan",
		"keepWithNext",
		"",
		"pageBreakBefore",
		"",
		"",               //80
		"LineWrap",
		"eAsianEng",
		"eAsianNum",
		"indent",
		"left",
		"right",
		"prev",
		"next",
		"",
		"",               //90
		"borderFillIDRef",
		"offsetLeft",
		"offsetRight",
		"offsetTop",
		"offsetBottom",
		"connect",
		"ignoreMargin",
		"engName",
		"nextStyleIDRef",
		"langID",         //100
		"id",
		"lockForm",
		"name",
		"textFlow",
		"textWrap",
		"zOrder",
		"numberingType",
		"widthRelTo",
		"heightRelTo",
		"treatAsChar",    //110
		"affectLSpacing",
		"vertRelTo",
		"vertAlign",
		"horzRelTo",
		"horzAlign",
		"vertOffset",
		"horzOffset",
		"flowWithText",
		"allowOverlap",
		"top",            //120
		"bottom",
		"side",
		"fullSz",
		"gap",
		"lastWidth",
		"e1",
		"e2",
		"e4",
		"e5",
		"e3",
		"e6",
		"headStyle",
		"headSz",
		"tailStyle",
		"tailSz",
		"radius",
		"direction",
		"distance",
		"rotationStyle",
		"fadeDirection",
		"id",
		"repeatHeader",
		"rowCnt",
		"colCnt",
		"cellSpacing",
		"startRowAddr",
		"startColAddr",
		"endRowAddr",
		"endColAddr",
		"numType",
		"supscript",
		"subscript",
		"fieldid",
		"pos",
		"formatType",
		"sideChar",
		"colCount",
		"sameSz",
		"sameGap",
		"version",
		"baseLine",
		"baseUnit",
		"lineMode",
		"x",
		"y",
		"x1",
		"y1",
		"x2",
		"y2",
		"fontName",
		"fontStyle",
		"fontType",
		"textShape",
		"spacing",

		"pageBreak",
		"columnBreak",
	},
// HWPML
	{
		"ParaShape",
		"Style",
		"CharShape",
		"APath",
		"RPath",
		"Format",
		"Type",
		"Name",
		"FamilyType",
		"SerifStyle",     //10
		"Weight",
		"Proportion",
		"Contrast",
		"StrokeVariation",
		"ArmStyle",
		"Letterform",
		"Midline",
		"XHeight",
		"ThreeD",
		"Shadow",         //20
		"Slash",
		"BackSlash",
		"CrookedSlash",
		"CounterSlash",
		"CounterBackSlash",
		"BreakCellSeparateLine",
		"Width",
		"Color",
		"FaceColor",
		"HatchColor",     //30
		"HatchStyle",
		"Alpha",
		"Angle",
		"CenterX",
		"CenterY",
		"Step",
		"ColorNum",
		"StepCenter",
		"Value",
		"Mode",           //40
		"Bright",
		"Effect",
		"BinItem",
		"Height",
		"TextColor",
		"ShadeColor",
		"UseFontSpace",
		"UseKerning",
		"SymMask",
		"BorderFillId",   //50
		"Shape",
		"OffsetX",
		"OffsetY",
		"AutoTabLeft",
		"AutoTabRight",
		"Leader",
		"Start",
		"Level",
		"Aligment",
		"UseInstWidth",   //60
		"AutoIndent",
		"WidthAdjust",
		"TextOffsetType",
		"TextOffset",
		"NumFormat",
		"Char",
		"Image",
		"Align",
		"VerAlign",
		"HeadingType",    //70
		"TabDef",
		"BreakLatinWord",
		"BreakNonLatinWord",
		"Condense",
		"WidowOrphan",
		"KeepWithNext",
		"KeepLines",
		"PageBreakBefore",
		"FontLineHeight",
		"SnapToGrid",     //80
		"LineWrap",
		"AutoSpaceEAsianEng",
		"AutoSpaceEAsianNum",
		"Indent",
		"Left",
		"Right",
		"Prev",
		"Next",
		"LineSpacingType",
		"LineSpacing",    //90
		"BorderFill",
		"OffsetLeft",
		"OffsetRight",
		"OffsetTop",
		"OffsetBottom",
		"Connect",
		"IgnoreMargin",
		"EngName",
		"NextStyle",
		"LangId",         //100
		"InstId",
		"LockForm",
		"Name",
		"TextFlow",
		"TextWrap",
		"ZOrder",
		"NumberingType",
		"WidthRelTo",
		"HeightRelTo",
		"TreatAsChar",
		"AffectLSpacing",
		"VertRelTo",
		"VertAlign",
		"HorzRelTo",
		"HorzAlign",
		"VertOffset",
		"HorzOffset",
		"FlowWithText",
		"AllowOverlap",
		"Top",
		"Bottom",
		"Side",
		"FullSize",
		"Gap",
		"LastWidth",
		"E1",
		"E2",
		"E4",
		"E5",
		"E3",
		"E6",
		"HeadStyle",
		"HeadSize",
		"TailStyle",
		"TailSize",
		"Radius",
		"Direction",
		"Distance",
		"RotationStyle",
		"FadeDirection",
		"BinData",
		"RepeatHeader",
		"RowCount",
		"ColCount",
		"CellSpacing",
		"StartRowAddr",
		"StartColAddr",
		"EndRowAddr",
		"EndColAddr",
		"NumberType",
		"Superscript",
		"Subscript",
		"InstId",
		"Pos",
		"FormatType",
		"SideChar",
		"Count",
		"SameSize",
		"SameGap",
		"Version",
		"BaseUnit",
		"BaseLine",
		"LineMode",
		"X",
		"Y",
		"X1",
		"Y1",
		"X2",
		"Y2",
		"FontName",
		"FontStyle",
		"FontType",
		"TextShape",
		"Spacing",

		"PageBreak",
		"ColumnBreak"
	}
};

inline const char* GetAttributeName(EAttribute eNode, EHanType eType)
{
	switch (eType)
	{
		case EHanType::HWPX:  return ATTRUBUTE_NAMES[0][static_cast<int>(eNode)];
		case EHanType::HWPML: return ATTRUBUTE_NAMES[1][static_cast<int>(eNode)];
		default: return "";
	}
}

inline bool Equals(EAttribute eAttribute, EHanType eType, std::string sAttributeName)
{
	switch (eType)
	{
		case EHanType::HWPX:  return ATTRUBUTE_NAMES[0][static_cast<int>(eAttribute)] == sAttributeName;
		case EHanType::HWPML: return ATTRUBUTE_NAMES[1][static_cast<int>(eAttribute)] == sAttributeName;
		default: return false;
	}
}

// TODO:: пока всё в одном месте. Возможно стоит лучше разделить по соответствующим классам
enum class EValue
{
	None,
	Center,
	CenterBelow,
	CenterAbove,
	All,
	RealPic,
	GrayScale,
	BlackWhite,
	Drop,
	Continuous,            //10
	Left,
	Right,
	Percent,
	HwpUnit,
	Digit,
	HangulSyllable,
	HangulJamo,
	CircledDigit,
	LatinSmall,
	CircledHangulSyllable, //20
	CircledHangulJamo,
	RomanSmall,
	Para,
	Char,
	BothSides,
	LeftOnly,
	RightOnly,
	LargestOnly,
	Square,
	TopAndBottom,          //30
	BehindText,
	InFrontOfText,
	Figure,
	Table,
	Equation,
	Top,
	Bottom,
	SmallSmall,
	SmallMedium,
	SmallLarge,            //40
	MediumSmall,
	MediumMedium,
	MediumLarge,
	LargeSmall,
	LargeMedium,
	LargeLarge,
	Normal,
	Arrow,
	Spear,
	ConcaveArrow,          //50
	EmptyDiamond,
	EmptyCircle,
	EmptyBox,
	RomanCapital,
	LatinCapital,
	CircledLatinCapital,
	CircledLatinSmall,
	HangulPhonetic,
	Ideograph,
	CircledIdeograph,      //60
	DecagonCircle,
	DecagonCircleHanja,
	Symbol,
	UserChar,
	Hyperlink,
	Bookmark,
	Line,
	Curve,
	Page,
	Footnote,              //70
	Endnote,
	TotalPage,
	Inside,
	Outside,
	Paper,
	Column,
	Absolute,
	Solid,
	Dash,
	Dot,                   //80
	DashDot,
	DashDotDot,
	LongDash,
	Circle,
	DoubleSlim,
	Thick,
	SlimThick,
	ThickSlim,
	SlimThickSlim,
	Diamond,               //90
	Box,
	Discrete,
	Outline,
	Number,
	Bullet,
	Distribute,
	DistributeSpace,
	Justify,
	Baseline,
	Pie,                   //100
	Chord,
	TopLeft,
	TopCenter,
	TopRight,
	BottomLeft,
	BottomCenter,
	BottomRight,
	TopOuter,
	BottomOuter,
	TopInner,              //110
	BottomInner
};

#define MAX_VALUES 111

static constexpr const char* VALUE_NAMES[MAX_TYPES][MAX_VALUES] = 
{
//HWPX
	{
		"NONE",
		"CENTER",
		"CENTER_BELOW",
		"CENTER_ABOVE",
		"ALL",
		"REAL_PIC",
		"GRAY_SCALE",
		"BLACK_WHITE",
		"DROP",
		"CONTINUOUS",              //10
		"LEFT",
		"RIGHT",
		"PERCENT",
		"HWPUNIT",
		"DIGIT",
		"HANGUL_SYLLABLE",
		"HANGUL_JAMO",
		"CIRCLED_DIGIT",
		"LATIN_SMALL",
		"CIRCLED_HANGUL_SYLLABLE", //20
		"CIRCLED_HANGUL_JAMO",
		"ROMAN_SMALL",
		"PARA",
		"CHAR",
		"BOTH_SIDES",
		"LEFT_ONLY",
		"RIGHT_ONLY",
		"LARGEST_ONLY",
		"SQUARE",
		"TOP_AND_BOTTOM",
		"BEHIND_TEXT",
		"IN_FRONT_OF_TEXT",
		"PICTURE",
		"TABLE",
		"EQUATION",
		"TOP",
		"BOTTOM",
		"SMALL_SMALL",
		"SMALL_MEDIUM",
		"SMALL_LARGE",
		"MEDIUM_SMALL",
		"MEDIUM_MEDIUM",
		"MEDIUM_LARGE",
		"LARGE_SMALL",
		"LARGE_MEDIUM",
		"LARGE_LARGE",
		"NORMAL",
		"ARROW",
		"SPEAR",
		"CONCAVE_ARROW",
		"EMPTY_DIAMOND",
		"EMPTY_CIRCLE",
		"EMPTY_BOX",
		"ROMAN_CAPITAL",
		"LATIN_CAPITAL",
		"CIRCLED_LATIN_CAPITAL",
		"CIRCLED_LATIN_SMALL",
		"HANGUL_PHONETIC",
		"IDEOGRAPH",
		"CIRCLED_IDEOGRAPH",
		"DECAGON_CIRCLE",
		"DECAGON_CRICLE_HANGJA",
		"SYMBOL",
		"USER_CHAR",
		"HYPERLINK",
		"BOOKMARK",
		"LINE",
		"CURVE",
		"PAGE",
		"FOOTNOTE",
		"ENDNOTE",
		"TOTAL_PAGE",
		"INSIDE",
		"OUTSIDE",
		"PAPER",
		"COLUMN",
		"ABSOLUTE",
		"SOLID",
		"DASH",
		"DOT",
		"DASH_DOT",
		"DASH_DOT_DOT",
		"LONG_DASH",
		"CIRCLE",
		"DOUBLE_SLIM",
		"THICK",
		"SLIM_THICK",
		"THICK_SLIM",
		"SLIM_THICK_SLIM",
		"DIAMOND",
		"BOX",
		"DISCRETE",
		"OUTLINE",
		"NUMBER",
		"BULLET",
		"DISTRIBUTE",
		"DISTRIBUTE_SPACE",
		"JUSTIFY",
		"BASELINE",
		"PIE",
		"CHORD",
		"TOP_LEFT",
		"TOP_CENTER",
		"TOP_RIGHT",
		"BOTTOM_LEFT",
		"BOTTOM_CENTER",
		"BOTTOM_RIGHT",
		"TOP_OUTER",
		"BOTTOM_OUTER",
		"TOP_INNER",
		"BOTTOM_INNER"
	},
//HWPML
	{
		"None",
		"Center",
		"CenterBelow",
		"CenterAbove",
		"All",
		"RealPic",
		"GrayScale",
		"BlackWhite",
		"Drop",
		"Cont",                  //10
		"Left",
		"Right",
		"Percent",
		"HwpUnit",
		"Digit",
		"HangulSyllable",
		"HangulJamo",
		"CircledDigit",
		"LatinSmall",
		"CircledHangulSyllable", //20
		"CircledHangulJamo",
		"RomanSmall",
		"Para",
		"Char",
		"BothSides",
		"LeftOnly",
		"RightOnly",
		"LargestOnly",
		"Square",
		"TopAndBottom",
		"BehindText",
		"InFrontOfText",
		"Figure",
		"Table",
		"Equation",
		"Top",
		"Bottom",
		"SmallSmall",
		"SmallMedium",
		"SmallLarge",
		"MediumSmall",
		"MediumMedium",
		"MediumLarge",
		"LargeSmall",
		"LargeMedium",
		"LargeLarge",
		"Normal",
		"Arrow",
		"Spear",
		"ConcaveArrow",
		"EmptyDiamond",
		"EmptyCircle",
		"EmptyBox",
		"RomanCapital",
		"LatinCapital",
		"CircledLatinCapital",
		"CircledLatinSmall",
		"HangulPhonetic",
		"Ideograph",
		"CircledIdeograph",
		"DecagonCircle",
		"DecagonCircleHanja",
		"Symbol",
		"UserChar",
		"Hyperlink",
		"Bookmark",
		"Line",
		"Curve",
		"Page",
		"Footnote",
		"Endnote",
		"TotalPage",
		"Inside",
		"Outside",
		"Paper",
		"Column",
		"Absolute",
		"Solid",
		"Dash",
		"Dot",
		"DashDot",
		"DashDotDot",
		"LongDash",
		"Circle",
		"DoubleSlim",
		"Thick",
		"SlimThick",
		"ThickSlim",
		"SlimThickSlim",
		"Diamond",
		"Box",
		"Discrete",
		"Outline",
		"Number",
		"Bullet",
		"Distribute",
		"DistributeSpace",
		"Justify",
		"Baseline",
		"Pie",
		"Chord",
		"TopLeft",
		"TopCenter",
		"TopRight",
		"BottomLeft",
		"BottomCenter",
		"BottomRight",
		"TopOuter",
		"BottomOuter",
		"TopInner",
		"BottomInner"
	}
};

inline const char* GetValueName(EValue eValue, EHanType eType)
{
	switch (eType)
	{
		case EHanType::HWPX:  return VALUE_NAMES[0][static_cast<int>(eValue)];
		case EHanType::HWPML: return VALUE_NAMES[1][static_cast<int>(eValue)];
		default: return "";
	}
}

#define CHECK_IF_ATTRIBUTE(type) if (GetAttributeName(EAttribute::type, eType) == sAttributeName)
#define CHECK_ELSE_IF_ATTRIBUTE(type) else CHECK_IF_ATTRIBUTE(type)
}

#endif // NODENAMES_H
